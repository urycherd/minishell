1.	разобрать все разрешенные функции

	execve	- запускает бинарники типа ls 
	kill	- отправляет сигналы процессам
	wait	- ждет, пока дочерний процесс закончится 
	dup		- дублирует файловый дескриптор

	0 stdin, 1 stdout, 2 stderr 

2.	разобрать проект на части

	0) парсинг
		- переменные окружения (знак доллара) (если сделать echo $PATH$qwe то PATH напечатается и qwe тоже, без пробелов)
			чекнуть еще "qwe"'qwe' - это все один большой аргумент
		- кавычки
			двойные и одинарные - их отличия
			одинарные - сильные, потому что все, что внутри одинарных передастся дальше в неизменном виде 
			двойные - слабые кавычки, так как внутри них все еще распознаются спецсимволы \ $ и двойные кавычки

			посмотреть комбинации разных кавычек

			незакрытые кавычки обрабатывать не нужно (по сабжекту)
			можно на этапе парсинга закрывать их за пользователя

			 e''cho biba тоже должно работать
		- экранирование символов
			в одинарных кавычках
			в двойных кавычках
			без кавычек

				нужно чекнуть экранирование слэша
		- пайпы, редиректы
		- точка с запятой
			посмотреть как ведет себя "ls ofhsdofh ; pwd" и "ls pdfsidf && pwd"
			если вообще встретилась точка с запятой, то нужно сразу отработать программу до нее
		- команды с путем и без
			пример: ls и ./ls
		- спец символы

	1) реализация built-in команд
		exit - нужно поковыряться, ему можно передавать аргументы
		echo
		cd
		pwd - getcwd (?)
		env - переменные окружения (пары ключ-значение)
			int main(int ac, char **av, **envp) - третий аргумент это переменные окружения

			export  без аргументов делает то же самое!! только с припиской  declare -x 

			а вообще export добавляет/изменяет пременные окружения, например export PWD=biba/boba
		unset - удаляет значение переменной окружения 
			unset PATH ; ls
	2) сигналы 
	3) запуск внешних программ
	4) логика редиректов/пайпов
	5) обработка ошибок (command not found, no such file or directory, permission denied, syntax error near unexpected token etc.)
	6) пайпы 
		int fd[2];
		pipe(fd);
		fd[0] - из которого читаем
		fd[1] - в который пишем

		dup нужен 
3. поделить задачи с тиммейтом
	1) точки входы и выхода наших кусков кода
	2) в каком виде передаем данные (сколько аргументов и какие и так далее)
	3) определить структуры данных, с которыми будем работать

	СОВЕТЫ ОТ СОНИКА: 
		хорошо, когда один пайп не отличается от пяти пайпов. то же про редиректы
		очень плохо делать сплит строки по пробелам. лучше идти посимвольно.

	Насчет execve: нужно сдлеать форк, и в нем запукать команду  




USEFUL LINKS

https://sites.cs.ucsb.edu/~manish/discussion/week2.pdf
https://tproger.ru/translations/unix-shell-in-c/
https://www.geeksforgeeks.org/making-linux-shell-c/
https://www.geeksforgeeks.org/developing-linux-based-shell/

https://edu.vsu.ru/pluginfile.php?file=%2F80770%2Fmod_resource%2Fcontent%2F1%2F%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B%20%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B3%D0%BE%20%D1%80%D0%B0%D0%B7%D0%B1%D0%BE%D1%80%D0%B0.pdf
https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
https://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_07
https://ruslanspivak.com/lsbasi-part7/
https://www.oilshell.org/blog/2016/10/18.html (here_doc)